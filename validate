#!/usr/bin/env python3
# Copyright (C) 2023 Reece H. Dunn. SPDX-License-Identifier: Apache-2.0
import sys

import conllutil
import argparse
import os


upos_values = [
    '_',      # missing
    # open class words
    'ADJ',    # adjective
    'ADV',    # adverb
    'INTJ',   # interjection
    'NOUN',   # noun
    'PROPN',  # proper noun
    'VERB',   # verb
    # closed class words
    'ADP',    # adposition
    'AUX',    # auxiliary verb
    'CCONJ',  # coordinating conjunction
    'DET',    # determiner
    'NUM',    # number
    'PART',   # part
    'PRON',   # pronoun
    'SCONJ',  # subordinating conjunction
    # other
    'PUNCT',  # punctuation
    'SYM',    # symbol
    'X',      # other
]

upenn_xpos_values = [
    "ADD", "AFX",
    "CC", "CD",
    "DT",
    "EX",
    "FW",
    "GW",
    "HYPH",
    "IN",
    "JJ", "JJR", "JJS",
    "LS",
    "MD",
    "NFP", "NN", "NNP", "NNPS", "NNS",
    "PDT", "POS", "PRP", "PRP$",
    "RB", "RBR", "RBS", "RP",
    "SYM",
    "TO",
    "UH",
    "VB", "VBD", "VBG", "VBN", "VBP", "VBZ",
    "WDT", "WP", "WP$", "WRB",
    "$", ".", ",", ":", "``", "''",
    "-LCB-", "-RCB-", "-LRB-", "-RRB-", "-LSB-", "-RSB-",
]

error_count = 0


class LogLevel:
    ERROR = 'ERROR'


def log(level, sent, token, message, expect=None, actual=None):
    if level == LogLevel.ERROR:
        global error_count
        error_count = error_count + 1

    if token is None:
        print(f"{level}: Sentence {sent.metadata['sent_id']} -- {message}")
    else:
        print(f"{level}: Sentence {sent.metadata['sent_id']} token {token['id']} -- {message}")

    if expect is not None and actual is not None:
        print(f"... Expect: {expect}")
        print(f"... Actual: {actual}")


def is_mwt_start(form):
    return form[-1].isalpha()


def is_mwt_end(form):
    if form[0] in ['\'', 'â€™']:
        for c in form:
            if c.isalpha():
                return True
    return form[0].isalpha()


def validate_sentence_text(sent, language):
    token_text = ""
    word_text = ""
    need_space = False
    last_mwt_id = 0
    need_mwt_space = False
    for token in sent:
        if type(token['id']) is int:
            if need_space:
                token_text += " "
                word_text += " "
            if last_mwt_id >= token['id']:
                if last_mwt_id == token['id']:
                    need_space = need_mwt_space
                else:
                    need_space = False
            else:
                need_space = conllutil.get_misc(token, 'SpaceAfter', 'Yes') == 'Yes'
                if last_mwt_id < token['id']:
                    token_text += token['form']
            word_text += token['form']
        elif '-' in token['id']:
            if need_space:
                token_text += " "
                word_text += " "
                need_space = False
            last_mwt_id = token['id'][2]
            need_mwt_space = conllutil.get_misc(token, 'SpaceAfter', 'Yes') == 'Yes'
            token_text += token['form']

    if 'text' in sent.metadata:
        if token_text != sent.metadata['text']:
            log(LogLevel.ERROR, sent, None, "text does not match the token sequence",
                expect=sent.metadata['text'],
                actual=token_text)
        if language == 'en' and word_text != sent.metadata['text']:
            log(LogLevel.ERROR, sent, None, "text does not match the word sequence",
                expect=sent.metadata['text'],
                actual=word_text)
    else:
        log(LogLevel.ERROR, sent, None, "sentence text is missing")


def validate_pos_tags(sent, language):
    for token in sent:
        if type(token['id']) is int:
            upos = token['upos']
            xpos = token['xpos']
            if upos not in upos_values:
                log(LogLevel.ERROR, sent, token, f"unknown UPOS value '{upos}'")
            if language == 'en' and xpos not in upenn_xpos_values:
                log(LogLevel.ERROR, sent, token, f"unknown XPOS value '{xpos}'")


def validate_mwt_tokens(sent, language):
    first_mwt_id = 0
    last_mwt_id = 0
    prev_form = ' '
    for token in sent:
        if type(token['id']) is int:
            form = token['form']
            if last_mwt_id < token['id'] or first_mwt_id == token['id']:
                if is_mwt_start(prev_form) and is_mwt_end(form) and not token['deprel'] == 'reparandum':
                    log(LogLevel.ERROR, sent, token,
                        f"multi-word continuation without a multi-word token range for '{prev_form}][{form}'")
            elif conllutil.get_misc(token, 'SpaceAfter', 'Yes') == 'No':
                log(LogLevel.ERROR, sent, token, f"multi-word token contains a SpaceAfter=No annotation")

            if conllutil.get_misc(token, 'SpaceAfter', 'Yes') == 'Yes':
                prev_form = ' '
            elif conllutil.get_misc(token, 'CorrectSpaceAfter', 'No') == 'Yes':
                prev_form = ' '
            else:
                prev_form = form
        else:
            first_mwt_id = token['id'][0]
            last_mwt_id = token['id'][2]


def validate_conllu(filename, default_language, validator):
    language = default_language
    for sent in conllutil.parse_conllu(filename):
        if 'newdoc' in sent.metadata or 'newdoc id' in sent.metadata:
            language = sent.metadata.get('dc:language', default_language).split('-')[0]
        validator(sent, language)


def validate_files(filename, default_language, validator):
    if filename.endswith('.lst'):
        dirname = os.path.dirname(filename)
        for file in conllutil.parse_filelist(filename):
            conllu_filename = os.path.join(dirname, file)
            validate_conllu(conllu_filename, default_language, validator)
    else:
        validate_conllu(filename, default_language, validator)


validators = {
    'sentence-text': validate_sentence_text,
    'pos-tags': validate_pos_tags,
    'mwt-tokens': validate_mwt_tokens,
}


def build_argparse():
    parser = argparse.ArgumentParser()
    parser.add_argument('input',
                        help='The CoNLL-U file to validate.')

    parser.add_argument('--language', default='und', type=str,
                        help='The language to use for the document if none is specified in the metadata.')
    parser.add_argument('--validator', default='sentence-text', type=str,
                        help='The validation tests to run.')

    return parser


def main():
    args = build_argparse().parse_args()
    validate_files(args.input,
                   default_language=args.language,
                   validator=validators[args.validator])
    if error_count > 0:
        sys.exit(1)


if __name__ == '__main__':
    main()
